
# The Links Theory 0.0.2
[Data Engineering] [Open source] [Математика] [Ненормальное программирование] [Программирование]
https://habr.com/ru/articles/895896/  
**Перевод**

[Автор оригинала: Vasily Solopov, Roman Vertushkin, Ivan Glazunov, Konstantin Diachenko]

Прошлого 1 апреля, как вы могли догадаться, мы пошутили. Пришло время это исправить, и теперь всё серьезно.

**TL;DR (слишком длинно; не читал)**

Эта статья содержит много букв, но её можно представить всего 4 символами из [теории множеств]:

L → L²

Всё остальное следует из них.

## Обзор

Эта статья в первую очередь предназначена для программистов и математиков, однако мы разработали её так, чтобы она была доступна всем, кто интересуется представленными идеями. Мы считаем, что обсуждаемые здесь концепции могут служить источником вдохновения для широкого спектра научных дисциплин.

Наша цель состояла в создании самодостаточного текста, который проводит вас через каждую тему в четком логическом порядке. На протяжении статьи вы найдете ссылки на [Wikipedia] для тех, кто хочет изучить конкретные термины или концепции более глубоко — но это полностью опционально. Текст предназначен для легкого понимания при чтении от начала до конца.

Каждый символ и формула объясняются индивидуально, с краткими определениями там, где это необходимо. Мы также добавили изображения, чтобы помочь проиллюстрировать ключевые идеи. Если вы столкнетесь с чем-то непонятным, пожалуйста, дайте нам знать, чтобы мы могли это улучшить.

## Сравнение теорий

Для быстрого погружения мы начинаем со сравнения математических основ двух самых популярных [моделей данных] с [ассоциативной моделью данных].

В ходе нашего исследования мы обнаружили, что традиционные теории иногда были излишне сложными или избыточными, а в других случаях накладывали слишком много искусственных ограничений.

Этот общий недостаток гибкости, адаптируемости и универсальности мотивировал нас на поиск более простой, но всеобъемлющей информационной теории и модели хранения данных, которую будущий искусственный интеллект мог бы легко понять и эффективно использовать. По пути мы черпали вдохновение в работе нашей собственной ассоциативной памяти и ассоциативных мыслительных процессов.

## Реляционная алгебра

[Реляционная алгебра] и [реляционная модель] основаны на концепциях [отношений] и [n-кортежей].

[Отношение] определяется как [множество] [n-кортежей]:

R ⊆ D₁ × D₂ × ... × Dₙ

[1]

![Рис. 1. Таблица описывается отношением , которое представляется множеством строк , принадлежащих декартову произведению .](media/image1.png)

**Рисунок 1.** Таблица описывается [отношением], которое представляется как [множество] [строк], принадлежащих [декартову произведению].

**Где:**

- Символ R обозначает [отношение] ([таблицу]);
- Символ ⊆ указывает, что левая часть [выражения] является [подмножеством] правой части;
- Символ × обозначает [декартово произведение] двух [множеств];
- Выражение Dᵢ представляет [домен], т.е. [множество] всех возможных [значений], которые каждая [ячейка] в [столбце] может содержать.

[Строки], или [элементы] [отношения], представляются как [n-кортежи].

[Данные] в [реляционной модели] группируются в [отношения]. Используя [n-кортежи] в этой [модели], можно точно представить любую conceivable [структуру данных], если бы мы действительно когда-либо использовали [n-кортежи] для этого. А нужны ли вообще [n-кортежи]? Например, каждый [n-кортеж] может быть представлен как [вложенные упорядоченные пары], что suggests, что одних [упорядоченных пар] может быть достаточно для представления любых [данных]. Более того, необычно, чтобы значения [столбцов] в [таблицах] представлялись как [n-кортежи] (хотя, например, [число] может быть [разложено] на [n-кортеж] [битов]). В некоторых [SQL] [базах данных] даже запрещено использовать более [столбцов] в [таблице] (и, соответственно, в соответствующем [n-кортеже]). Таким образом, фактическое значение n обычно меньше ∞. Поэтому в этих случаях нет [истинных] [n-кортежей] — даже в современных [реляционных] [базах данных].

![Рис. 2. Сравнение реляционной модели и ассоциативной модели данных (изначальная модель Саймона Вильямса была упрощена дважды). Иными словами для представления всех данных в реляционной модели требуется множество таблиц под каждый тип данных, в ассоциативной модели как оказалось было достаточно сначала двух таблиц, а потом и вовсе одной таблицы триплетов или дуплетов.](media/image2.png)

**Рисунок 2.** Сравнение [реляционной модели] и [ассоциативной модели данных] (исходная [модель], предложенная [Саймоном Вильямсом], была нами упрощена дважды) [3]. Другими словами, представление всех [данных] в [реляционной модели] требует множества [таблиц] — по одной для каждого [типа данных] — тогда как в [ассоциативной модели] оказалось, что изначально было достаточно всего двух [таблиц] (элементы и связи), и в конечном итоге достаточно одной [таблицы] (связи) [триплет]-связей или [дуплет]-связей.

## Ориентированный граф

Ориентированные графы — и [графы] в целом — основаны на концепциях [вершин] и [рёбер] ([2-кортежей]).

[Ориентированный граф] G определяется следующим образом:

G = (V, E)

[2]

**Где:**

- V — это [множество], элементы которого называются [вершинами], узлами или [точками];
- E — это множество [упорядоченных пар] (2-[кортежей]) [вершин], называемых дугами, направленными [рёбрами] (иногда просто [рёбрами]), стрелками или направленными [отрезками линий].

В модели ориентированного графа данные представлены двумя отдельными [множествами]: [узлами] и [рёбрами]. Эта [модель] может использоваться для представления почти всех [структур данных], за исключением, возможно, [последовательностей] ([n-кортежей]). Иногда для представления последовательностей используются цепочки вершин. Хотя этот метод работает, он неизбежно приводит к дублированию данных, и дедупликация в таких случаях либо сложна, либо невозможна. Более того, последовательности в графах могут быть представлены путем [разложения последовательности на вложенные множества], но, на наш взгляд, это непрактичный подход. Кажется, мы не одиноки в этом убеждении, что может объяснять, почему мы не встречали примеров использования такого метода другими.

![Рис. 3. Сравнение теории графов и теории связей. Вершина эквивалентна замкнутой на себя связи, то есть связи которая в себе начинается и в себе заканчивается. Направленное ребро отображается в направленную связь-дуплет. А ненаправленное ребро отображается в пару направленных связей-дуплетов в обоих направлениях. То есть если в теории графов требуется два типа сущностей - вершины и рёбра, то в теории связей достаточно только связей (больше всего похожих на рёбра).](media/image3.png)

**Рисунок 3.** Сравнение теории графов и теории связей. Вершина эквивалентна [связи, замкнутой на себя] — связи, которая начинается и заканчивается в себе. Направленное ребро представляется как направленная дуплет-связь, а ненаправленное ребро представляется как пара направленных дуплет-связей в обоих противоположных направлениях. Другими словами, в то время как теория графов требует два типа сущностей — вершин и рёбер — в теории связей необходимы только связи (которые больше всего похожи на рёбра).

## Теория связей

Теория связей основана на концепции связи.

В проекции теории связей в теорию множеств, [связь] определяется как [n-кортеж] ссылок на связи, который имеет свою собственную ссылку, которую другие связи могут использовать для ссылки на него.

Стоит отметить, что отдельное понятие ссылки требуется здесь исключительно потому, что [циклические определения] недоступны в теории множеств. Фактически, теория связей может описывать себя без необходимости в отдельном термине для ссылки — другими словами, ссылка — это просто частный случай связи.

### Дуплеты

Дуплет-связь представляется дуплетом (2-кортежем или [упорядоченной парой]) ссылок на связи. Дуплет-связь также имеет свою собственную ссылку.

L = {1, 2}

L × L = {
(1, 1),
(1, 2),
(2, 1),
(2, 2),
}

**Где:**

- L — множество ссылок (от английского слова "Links" в значении "Ссылки").

В этом примере множество L содержит только 2 ссылки на связи, а именно 1 и 2. Другими словами, в сети связей, построенной на таком множестве ссылок, может быть только 2 связи.

Чтобы получить все возможные значения связи, используется [декартово произведение] L на себя, т.е. L × L.

![alt text](media/image4.png)

**Рисунок 4.** Матрица, представляющая декартово произведение множества {1, 2} на себя. Здесь мы видим, что связи с двумя ссылками на связи могут иметь только 4 возможных значения.

![alt text](media/image5.png)

**Рисунок 5.** Таблица строк, содержащая все возможные варианты значений связей для сети с двумя связями; эти варианты получены с использованием декартова произведения {1, 2} на себя.

**Сеть дуплет-связей** определяется как:

anetᴅ: L → L × L

**Где:**

- → обозначает [отображение (функцию)];
- anetᴅ представляет функцию, определяющую сеть дуплет-связей;
- L обозначает множество ссылок на связи.

**Пример:**

anetᴅ = {1 ↦ (1, 1), 2 ↦ (1, 2), 3 ↦ (2, 1)}

![alt text](media/image6.png)

**Рисунок 6. Сеть из трёх связей.** Представление сети дуплет-связей напоминает граф, но мы называем эту визуализацию сетью связей. Первая и вторая связи имеют схожую структуру — то есть обе начинаются из самих себя и заканчиваются в самих себе. В результате вместо традиционного изображения вершины как точки в теории графов мы получаем графическое представление замкнутой самоссылающейся стрелки, напоминающей символ бесконечности.

![alt text](media/image7.png)

**Рисунок 7.** Это графическое представление декартова произведения в виде матрицы, которая отображает все возможные значения связей. Связи, определяющие конкретную сеть, выделены оранжевым. Другими словами, из 9 возможных вариантов значений связей выбрано только 3 связи, что соответствует размеру множества **L**.

Сеть дуплет-связей может представлять любую структуру данных.

Например, дуплет-связи могут:

- Связывать объект с его свойствами;
- Соединять две связи вместе, что определение теории графов не позволяет;
- Представлять любую последовательность (n-кортеж) как дерево, построенное из вложенных упорядоченных пар;
- Описывать предложение естественного языка, например, используя лингвистическую модель [подлежащее-сказуемое].

Благодаря этому и другим фактам, мы считаем, что дуплет-связи могут представлять любую conceivable структуру данных.

### Триплеты

Триплет-связь представляется триплетом (3-кортежем) ссылок на связи.

L = {1, 2}

L × L = {
(1, 1),
(1, 2),
(2, 1),
(2, 2),
}

L × L × L = {
(1, 1, 1),
(1, 1, 2),
(1, 2, 1),
(1, 2, 2),
(2, 1, 1),
(2, 1, 2),
(2, 2, 1),
(2, 2, 2),
}

![alt text](media/image8.png)

**Рисунок 8.** Трёхмерный куб-матрица, представляющая все возможные значения триплет-связи. Такой куб получается рекурсивным взятием декартова произведения множества {1, 2} на себя, т.е. {1, 2} × {1, 2} × {1, 2}.

![alt text](media/image9.png)

**Рисунок 9.** Таблица всех возможных вариантов значений триплет-связей, которые могут быть получены рекурсивным взятием декартова произведения множества {1, 2} на себя, т.е. {1, 2} × {1, 2} × {1, 2}. **Примечание:** Первую ссылку можно интерпретировать как начало, вторую как тип, а третью как конец; пользователь определяет, как интерпретировать компоненты вектора ссылок в соответствии с поставленной задачей.

**Сеть триплет-связей** определяется как:

anetᴛ: L → L × L × L

**Где:**

- anetᴛ обозначает функцию, определяющую сеть триплет-связей;
- L обозначает множество ссылок на связи.

Пример функции, задающей конкретную сеть триплет-связей:

anetᴛ = {1 ↦ (1, 1, 1), 2 ↦ (1, 2, 3), 3 ↦ (2, 4, 1), 4 ↦ (3, 1, 5)}

![alt text](media/image10.jpeg)

**Рисунок 10.** Ассоциативная триплет-сеть, представленная в виде цветного ориентированного графа. В этой ассоциативной сети есть 4 триплет-связи, соответствующие определённой выше функции. Узлы соответствуют связям, а цвета рёбер соответствуют ссылкам на связи, как показано на Рисунке 9 (красный — от, синий — тип, зелёный — к).

Триплет-связи могут выполнять те же функции, что и дуплет-связи. Поскольку триплет-связи включают дополнительную ссылку, этот дополнительный элемент может, например, использоваться для указания типа связи.

Например, триплет-связи могут:

- Связывать объект, его свойство и его значение;
- Связывать две связи вместе с использованием определённого отношения;
- Описывать предложение естественного языка, например, используя модель [подлежащее-сказуемое-дополнение].

### Последовательности

Последовательность ссылок на связи — также известная как [n-кортеж] — является общим случаем.

В общем случае, сеть связей определяется как:

anet: L → Lⁿ

**Где:**

- Символ anet обозначает функцию, определяющую сеть связей;
- Символ L обозначает множество ссылок на связи.

**Пример:**

anet = {1 ↦ (1, 2), 2 ↦ (1), 3 ↦ (1, 2, 3, 4)}

В этом примере в качестве значений связи используются n-кортежи переменной длины.

Последовательности (векторы) по своей сути эквивалентны по выразительной мощности реляционной модели — факт, который ещё предстоит доказать в рамках развивающейся теории. Однако, как только мы заметили, что дуплет-связей и триплет-связей достаточно для представления последовательностей любого размера, мы выдвинули гипотезу, что нет необходимости использовать последовательности напрямую, так как они представимы дуплет-связями.

## Итоги сравнения

[Реляционная модель данных] может представлять всё — даже [ассоциативную модель], но для этого необходимо ввести [вполне упорядоченность], что обычно происходит в форме отдельного столбца ID. Поскольку реляционная модель данных основана на понятии [множества] вместо [последовательности]. В contrast, модель графов преуспевает в представлении отношений, но менее эффективна в представлении уникальных дедуплицированных последовательностей.

Хотя сама реляционная модель не требует разделения данных по нескольким таблицам, традиционные реализации обычно принимают этот подход с фиксированными схемами, что приводит к фрагментации связанных данных и усложняет реконструкцию inherent отношений. В contrast, ассоциативная модель использует единое хранилище связей, которое достигает максимально возможной степени нормализации. Этот дизайн упрощает отображение бизнес-домена один-к-одному, тем самым облегчая быстрые изменения требований [4].

Ассоциативная модель может легко представлять n-кортежи неограниченной длины с помощью кортежей с n ≤ ∞. Она так же способна, как теория графов, в представлении ассоциаций, и так же мощна, как реляционная модель, будучи способной полностью представлять любую SQL-таблицу. Дополнительно, ассоциативная модель может представлять строгие последовательности, позволяя любой последовательности быть инкапсулированной в уникальную одиночную связь, что полезно для дедупликации.

В реляционной модели необходимо только одно отношение, чтобы имитировать поведение ассоциативной модели, и обычно требуется не более 2–3 столбцов помимо явного ID или встроенного ID строки. Сам ID требуется в реляционной модели, потому что она построена на концепции множества, в contrast, теория связей строится на концепции последовательности, поэтому явный ID не требуется (и может быть опционально добавлен, если пользователю действительно это нужно).

По определению, модель графов не может напрямую создать ребро между рёбрами. Таким образом, ей потребовалось бы либо переопределение, либо расширение с недвусмысленным методом хранения уникальных дедуплицированных последовательностей. Хотя последовательности могут храниться как [вложенные множества] в рамках модели графов, этот подход непопулярен. Хотя модель графов наиболее близка к дуплет-связям, она всё же отличается по определению.

Использование ассоциативной модели означает, что больше не нужно выбирать между SQL и NoSQL базами данных; вместо этого, ассоциативное хранилище данных может представлять всё самым простым возможным способом, с данными, всегда хранящимися в форме, наиболее близкой к исходной (обычно это нормализованная форма, но денормализация также возможна, если это необходимо).

## Математическое введение в теорию связей

### Введение

Теперь, когда мы кратко представили истоки нашей работы, пришло время углубиться в теорию.

Теория связей разрабатывается как более фундаментальная framework по сравнению с теорией множеств или теорией типов, и как замена реляционной алгебре и теории графов в качестве объединяющей теории. В то время как теория типов построена на базовых понятиях "тип" и "термин", а теория множеств на "множество" и "элемент", теория связей сводит всё к единой концепции "связи".

В этом разделе мы объясним основные концепции и терминологию, используемые в теории связей.

Затем мы представим определения теории связей в рамках теории множеств, и впоследствии спроецируем эти определения в теорию типов с использованием интерактивного доказателя теорем Coq.

Наконец, мы подведём итоги наших находок и наметим направления для дальнейших исследований и разработки теории связей.

### Теория связей

В основе теории связей лежит унифицированная концепция связи. Дополнительное понятие ссылки на связь вводится только для теорий, которые не поддерживают циклические определения — таких как теория множеств и теория типов.

### Связь

Связь обладает асимметричной рекурсивной (фрактальной) структурой, которую можно просто выразить как: связь **связывает** связи (как в "связь **соединяет** связи"). Термин "асимметричная" относится к тому факту, что каждая связь имеет направление — от её источника (начала) к её назначению (концу).

### Определения теории связей в рамках теории множеств

**Ссылка на вектор** — это уникальный идентификатор или порядковый номер, который ассоциирован с конкретным вектором, представляющим последовательность ссылок на другие векторы.

Множество ссылок на векторы: L ⊆ ℕ₀

**Вектор ссылок** — это вектор, состоящий из нуля или более ссылок на векторы, где количество ссылок соответствует количеству элементов в векторе.

Множество всех векторов ссылок длины n: Vₙ ⊆ Lⁿ

Декартова степень Lⁿ всегда производит вектор длины n, поскольку все его компоненты имеют один и тот же тип L.
Другими словами, Lⁿ представляет множество всех возможных n-элементных векторов (по сути n‑кортежей), в котором каждый элемент принадлежит множеству L.

**Ассоциация** — это упорядоченная пара, состоящая из ссылки на вектор и вектора ссылок. Эта структура служит отображением между ссылками и векторами.

**Ассоциативная сеть** векторов длины n (или n-мерная ассоциативная сеть) определяется семейством функций {anetvⁿ: L → Vₙ}, где каждая функция anetvⁿ отображает ссылку l ∈ L в вектор ссылок длины n, принадлежащий Vₙ, тем самым идентифицируя точки в n-мерном пространстве.
n в Vₙ указывает, что функция возвращает векторы, содержащие n ссылок. Каждая n-мерная ассоциативная сеть, таким образом, представляет последовательность точек в n-мерном пространстве.

**Семейство функций:**

{anetvⁿ: L → Vₙ} ⊆ Aₙ = L × Vₙ

Здесь символ объединения ⋃ обозначает агрегацию всех функций в семействе {anetvⁿ}, и символ ⊆ указывает, что эти упорядоченные пары — рассматриваемые как функциональные бинарные отношения — являются подмножеством множества Aₙ всех ассоциаций.

**Множество дуплетов (упорядоченных пар или 2-мерных векторов) ссылок:**

L² = { (l₁, l₂) | l₁, l₂ ∈ L }

Это множество всех дуплетов L × L, т.е. вторая декартова степень L.

**Ассоциативная сеть дуплетов (или 2-мерная ассоциативная сеть):**

{anetᴅ: L → L²} ⊆ A₂ = L × L²

Каждая ассоциативная сеть дуплетов, таким образом, представляет последовательность точек в двумерном пространстве.

Пустой вектор (вектор длины нуль) представляется пустым кортежем, обозначаемым как ⟨⟩ или ().

**Ассоциативная сеть вложенных упорядоченных пар:**

{anetʟ: L → NP} ⊆ A = L × NP

NP — это множество вложенных упорядоченных пар, состоящих из пустых пар и пар, содержащих один или более элементов. Таким образом, вектор длины n может быть представлен как вложенные упорядоченные пары.

## Проекция теории связей в теорию типов (Coq) через теорию множеств

### О Coq

[Coq] — это интерактивный доказатель теорем, основанный на теория типов высшего порядка, также известный как Исчисление Индуктивных Конструкций (CIC). Это мощная среда для формализации сложных математических теорем, проверки доказательств на корректность и извлечения исполняемого кода из формально верифицированных спецификаций. Coq широко используется как в академических кругах для формализации математики, так и в IT-индустрии для верификации программного и аппаратного обеспечения.

Решение использовать Coq для описания теории связей в рамках теории типов было driven необходимостью строгой формализации доказательств и assurance логической корректности во время разработки теории связей. Coq enables точное выражение свойств и операций над связями через его robust систему типов и advanced механизмы доказательств.

В anticipation обширной работы, направленной на доказательство эквивалентности реляционной модели и ассоциативной сети дуплетов, этот раздел представляет начальные шаги, предпринятые с использованием системы доказательств Coq. На первом этапе наша цель — формализовать структуры ассоциативных сетей, определив базовые типы, функции и структуры внутри Coq.

### Определения ассоциативных сетей

[[Ссылка на исходный код]]

(Из-за ограничения длины, код на Coq будет переведён, но не полностью воспроизведён здесь. Код включает определения для:)

- Множества ссылок на векторы (L)
- Множества векторов ссылок длины n (Vn)
- Множества всех ассоциаций (A)
- Ассоциативной сети векторов длины n (ANetVf, ANetVl)
- Вложенных упорядоченных пар (NP)
- Ассоциативной сети вложенных упорядоченных пар (ANetLf, ANetLl)
- Дуплета ссылок (D)
- Ассоциативной сети дуплетов (ANetDf, ANetDl)

### Функции для конвертации ассоциативных сетей

(Код включает функции для конвертации между различными представлениями ассоциативных сетей:)

- VnToNP — конвертация векторов в вложенные пары
- ANetVfToANetLf — конвертация функций сети векторов в функции сети пар
- ANetVlToANetLl — конвертация списков сети векторов в списки сети пар
- NPToVnOption, NPToVn — конвертация вложенных пар в векторы
- ANetLfToANetVf — конвертация функций сети пар в функции сети векторов
- ANetLlToANetVl — конвертация списков сети пар в списки сети векторов
- NPToANetDl — конвертация вложенных пар в сеть дуплетов
- AddNPToANetDl — добавление вложенных пар к сети дуплетов
- ANetDl_behead — удаление головы сети дуплетов
- ANetDlToNP — конвертация сети дуплетов в вложенные пары
- AddANetLlToANetDl — добавление списка сети пар к сети дуплетов
- ANetLlToANetDl — конвертация списка сети пар в сеть дуплетов
- ANetDl_offsetNP — поиск смещения вложенных пар в сети дуплетов
- ANetVlToANetDl — конвертация списка сети векторов в сеть дуплетов
- ANetDl_beheadNP — удаление первых вложенных пар из сети дуплетов
- ANetDlToANetLl — конвертация сети дуплетов в список сети пар

### Предикаты эквивалентности для ассоциативных сетей

(Определены предикаты для проверки эквивалентности различных представлений сетей.)

### Леммы эквивалентности ассоциативных сетей

(Доказаны леммы, включая:)

- Vn_dim_preserved — сохранение длины вектора
- H_inverse — взаимная инверсия функций NPToVnOption и VnToNP
- anetf_equiv_after_transforms — эквивалентность сетей после преобразований
- NP_dim_preserved — сохранение длины списков вложенных пар

### Примеры конвертаций между ассоциативными сетями

(Приведены примеры конвертаций между различными представлениями сетей с ожидаемыми результатами.)

## Практическая реализация

Существует несколько практических реализаций: [Deep], [LinksPlatform] и [модель отношений].

### Deep

[Deep] — это система, основанная на теории связей. В теории связей связи могут использоваться для представления любых данных или знаний, а также для выполнения программирования. Deep построена вокруг этой философии: в Deep всё есть связь. Однако, если мы разделим эти связи на две категории, у нас есть сами данные и поведение. Поведение — представленное кодом в Deep — хранится в ассоциативном хранилище как связи, и для выполнения передаётся в Docker-контейнер соответствующего языка программирования, где оно запускается изолированно и безопасно. Вся коммуникация между различными частями кода осуществляется через связи в хранилище (базе данных), что делает базу данных универсальным API на основе данных (в contrast с традиционной практикой вызова функций и методов). В настоящее время в качестве ассоциативного хранилища в Deep используется PostgreSQL, который позже будет заменён на движок данных на основе дуплетов и триплетов из LinksPlatform.

Deep делает всё программное обеспечение на планете интероперабельным, представляя все его части как связи. Также возможно хранить любые данные и код вместе, связывая события или действия на различных типах ассоциаций с соответствующим кодом, который выполняется для обработки этих событий. Каждый обработчик может извлекать необходимые связи из ассоциативного хранилища и вставлять/обновлять/удалять связи в нём, что может запускать дальнейшее каскадное выполнение обработчиков.

Таблица links в базе данных PostgreSQL Deep содержит записи, которые могут интерпретироваться как связи. Они имеют столбцы, такие как id, type_id, from_id и to_id. Типы связей помогают разработчику ассоциативных пакетов предопределить семантику отношений между различными элементами, обеспечивая однозначное понимание связей как людьми, так и кодом в ассоциативных пакетах. В дополнение к таблице links, система также включает таблицы numbers, strings и objects для хранения числовых, строковых и JSON-значений соответственно. Каждая связь может быть ассоциирована только с одним значением. Это временное решение, которое используется до тех пор, пока Deep не мигрирует на использование LinksPlatform в качестве движка базы данных. После завершения миграции все эти, казалось бы, базовые типы будут построены с нуля с использованием только связей. Это позволит использовать дедупликацию (которая возникает как следствие теории связей) и глубокое понимание внутренней структуры значений. Также планируется добавить индексацию таких сложных значений, представленных связями, чтобы улучшить производительность, сделав её такой же быстрой или быстрее, чем текущая реализация PostgreSQL.

### LinksPlatform

[LinksPlatform] — это кроссплатформенный, мультиязычный framework, направленный на предоставление низкоуровневой реализации ассоциативности в форме конструктора движка базы данных. Например, в настоящее время у нас есть [бенчмарк], который сравнивает реализацию дуплетов в PostgreSQL с аналогичной реализацией на чистом Rust/C++; лидирующая реализация на Rust превосходит PostgreSQL в [число] раз в операциях записи и в [число] раз в операциях чтения.

### Модель отношений

[Модель отношений] — это метаязык программирования, основанный на представлении программы как трёхмерной ассоциативной сети. Модель отношений придерживается entity-ориентированного программирования, где сущность используется как единая фундаментальная концепция — то есть предполагается, что всё есть сущность и нет ничего, кроме сущностей.

В модели отношений сущность, в зависимости от её внутреннего конститутивного принципа, может быть либо структурой (объектом), либо функцией (методом). В отличие от известной ER-модели, которая использует две базовые концепции — сущность и отношение — для представления схемы базы данных, в модели отношений сущность и отношение по сути одно и то же. Это представление позволяет описывать не только внешние отношения сущности, но и её внутреннюю модель — модель отношений.

Сущность, в своём внутреннем принципе, триедина (трёхсоставна, состоит из трёх элементов), потому что она является синтезом трёх аспектов (качеств) других сущностей (или самой себя).

[jsonRVM] — это многопоточная виртуальная машина для выполнения JSON-проекции модели отношений. Модель отношений, когда представлена как JSON, позволяет писать программы непосредственно в JSON. Это представление является гибридом сегментов данных и кода и позволяет легко десериализовать/выполнять/сериализовать проекцию модели отношений, а также использовать JSON-редакторы для программирования. В процессе выполнения модели отношений, мета-программа может не только обрабатывать данные, но и генерировать многопоточные программы и мета-программы, и либо выполнять их немедленно, либо экспортировать их как JSON.

## Заключение

В этой статье мы рассмотрели математические основы реляционной алгебры и теории графов, и представили определения теории связей в терминах теории множеств и её проекцию в теорию типов. Мы также определили набор функций и лемм, необходимых для доказательства возможности эквивалентной конвертации из любого вектора/последовательности во вложенные дуплет-связи и обратно. Это означает, что достаточно только одной формулы для представления любого возможного типа информации:

L → L²

Таким образом, это формирует основу для проверки гипотезы, что любая другая структура данных может быть представлена дуплет-связями. Другими словами, дуплет-связей достаточно для представления любых таблиц, графов, строк, массивов, списков, чисел, звука, изображений, видео и многого другого.

Другим следствием этого доказательства является то, что мы можем представлять ленту Машины Тьюринга, используя только дуплет‑связи. Это означает, что связи могут быть такими же мощными, как Машина Тьюринга в своей ёмкости хранения. Значит, мы можем использовать связи для всех случаев использования, где используется Машина Тьюринга. Но нет необходимости пытаться втиснуть данные в нули и единицы, нет необходимости ломать голову над этим. Потому что в связях "алфавит" по сути неограничен, и вы можете добавлять любое количество связей, присваивать им любой нужный вам смысл и связывать или соединять их вместе любым нужным вам способом. Обычно это означает, что ваша концепция, объект или вещь из реального или абстрактного мира будет отображена 1 к 1 в связи или так близко к оригиналу, как это возможно, что иногда невозможно традиционными методами.

Мы продолжаем добиваться прогресса в синхронизации смысла между нашими тремя проектами и среди людей в нашем ассоциативном сообществе. Эти проекты предназначены для того, чтобы привнести ассоциативность в мир и сделать её полезной для человечества. Эта статья — ещё одна итерация нашего обсуждения, позволяющая нам договориться о едином значении слов и терминов в рамках общей ассоциативной теории. Мы считаем, что эта теория может стать метаязыком, на котором уже используются люди и машины для общения.

С каждой дальнейшей доработкой мы будем на шаг ближе к тому, чтобы говорить на общем языке и делать эту идею более понятной для всех. Эта теория также будет полезна для различных оптимизаций в разрабатываемых ассоциативных реализациях, и в будущем, для проектирования ассоциативных чипов (или сопроцессоров) для ускорения операций с данными, представленными как связи.

## Планы на будущее

Эта статья продемонстрировала лишь небольшую часть всех разработок в теории связей, которые накопились за несколько лет работы и исследований. В последующих статьях будут постепенно раскрыты другие проекции теории связей, в терминах других теорий, таких как реляционная алгебра, теория графов, а также в терминах теории типов без прямого использования теории множеств, а также анализ различий с [ассоциативной моделью данных Саймона Вильямса] [3].

Мы также планируем спроецировать теорию связей в саму себя, показав, что она может использоваться как мета-теория. Это также откроет дверь для проекции теории множеств и теории типов в теорию связей, что означает, что мы теперь завершаем цикл определения (теория связей определена в теории множеств, которая сама может быть определена в теории связей). Мы также сможем сравнить теорию множеств, теорию типов, теорию графов, реляционную алгебру и теорию связей, что поможет нам проверить эквивалентность этих теорий или, по крайней мере, получить точную биективную функцию для конвертации между ними.

Также есть планы представить чёткую и унифицированную терминологию теории связей, её основные постулаты, аспекты и так далее. Текущий прогресс в разработке теории можно наблюдать в [репозитории deep-theory].

Чтобы получать обновления, мы рекомендуем подписаться на [блог Deep.Foundation] здесь или проверять нашу [работу на GitHub] сейчас, или напрямую связаться с нами в [нашем Telegram публичном чате] (особенно если вы боитесь получить минусы в комментариях).

Мы приветствуем любые отзывы, которые у вас могут быть, будь то на Хабре, GitHub или Telegram. Вы также можете участвовать в разработке теории или помочь ускорить её прогресс, взаимодействуя с нами любым способом.

## CLI демо

Теперь вы можете получить представление о том, как работает ассоциативная теория, используя наш [CLI демо-инструмент], который построен на [нотации связей] и [хранилище Дуплет-связей] из проекта [LinksPlatform]. [Нотация связей] — это язык для данных, выраженных только в связях и ссылках. [Дуплеты] — это движок базы данных, написанный на C# с нуля для поддержки только ассоциативного хранения и преобразований.

В этой демонстрации мы построили на нотации связей диалект, который способен описывать единственную универсальную операцию — подстановку. Как и с унификацией типов данных, также возможно унифицировать создание, чтение, обновление и удаление в единственную операцию подстановки. Это похоже на единственную операцию из [алгоритма Маркова], который доказан как [Тьюринг-полный].

![Figure 11. In this image you can see creation of two links (1: 1 1) and (2: 2 2); update of first link to (1: 1 2); update/substitution using variables to swap sources and targets of each link; and a deletion of all links using (* *) pattern.](media/image11.png)

**Рисунок 11.** На этом изображении вы можете видеть создание двух связей (1: 1 1) и (2: 2 2); обновление первой связи до (1: 1 2); обновление/подстановку с использованием переменных для обмена источниками и целями каждой связи; и удаление всех связей с использованием шаблона (* *).

## Визуальные демо

![Figure 12. Link blueprint designer build on top of a configurable spline: konard.github.io/links-visuals/blueprint.html (move control points of spline that represents the link)](media/image12.png)

**Рисунок 12.** Конструктор чертежей связей, построенный поверх настраиваемого сплайна: [konard.github.io/links-visuals/blueprint.html] (перемещайте контрольные точки сплайна, который представляет связь)

![Figure 13. H-tree like fractal build using links represented by straight arrows: konard.github.io/links-visuals/H-fractal.html (click at any place to iterate the fractal)](media/image13.jpeg)

**Рисунок 13.** Фрактал, похожий на [H-дерево], построенный с использованием связей, представленных прямыми стрелками: [konard.github.io/links-visuals/H-fractal.html] (щелкните в любом месте для итерации фрактала)

## P.S.

Эта и предыдущие статьи будут обновляться по мере развития и расширения теории связей в течение следующих 6 месяцев.

## P.S.S.

Если вы стали поклонником теории связей, мы приглашаем вас распространять эту формулу как мем-вирус в социальных сетях.

Используя символы Unicode:

L ↦ L²

Используя LaTeX:

L \to L^2

Которая отображается как SVG (кликабельно):

[Формула]

## Ссылки

1.  Edgar F. Codd, IBM Research Laboratory, San Jose, California, June 1970, ["Relational Model of Data for Large Shared Data Banks.", paragraph 1.3., page 379]
2.  Bender, Edward A.; Williamson, S. Gill (2010). ["Lists, Decisions and Graphs. With an Introduction to Probability.", section 2, definition 6, page 161]
3.  Simon Williams, Great Britain (1988), [The Associative Model Of Data]
4.  Homan, J. V., & Kovacs, P. J. (2009). [A Comparison of the Relational Database Model and the Associative Database Model]. Issues in Information Systems, X(1), 208.

---

**Примечание:** Полный перевод включает все разделы статьи, включая формальные определения, код на Coq и ссылки. Из-за ограничения длины некоторые части кода были сокращены, но ключевые концепции и определения переведены полностью.

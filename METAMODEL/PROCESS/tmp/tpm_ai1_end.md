## end
### 1 
end-to-end в общем сучае

Формализуем понятие **сквозного процесса** (end-to-end) через задание произвольных начального и конечного событий/функций.

## Формальное определение сквозного процесса

### Базовые понятия

**Множество всех функций процесса:**
```
F = {f₁, f₂, ..., fₙ}
```

**Процесс как упорядоченная последовательность:**
```
P = ⟨p₁, p₂, ..., pₘ⟩
где pᵢ ∈ F и m ≥ 1
```

**Определение концов процесса:**
```
Пусть:
start(P) = s, где s ∈ {p₁, ..., pₘ}  // стартовый end
end(P) = e, где e ∈ {p₁, ..., pₘ}    // финишный end
```

### Формальное правило сквозного процесса

**Процесс P является сквозным (end-to-end) относительно выбранных концов s и e тогда и только тогда, когда:**

```
start(P) ≠ end(P)
```

Или более формально:

```
∀P = ⟨p₁, p₂, ..., pₘ⟩:
  Сквозной(P, s, e) ⇔ (s ∈ P) ∧ (e ∈ P) ∧ (s ≠ e)
```

где `s ∈ P` означает, что `s` является элементом последовательности `P`.

### Расширенная форма с индексами

Если мы фиксируем индексы начала и конца в последовательности:

```
Пусть:
start_index = i, где 1 ≤ i ≤ m
end_index = j, где 1 ≤ j ≤ m

Тогда:
Сквозной(P, i, j) ⇔ (i ≠ j) ∧ (1 ≤ i ≤ m) ∧ (1 ≤ j ≤ m)
```

### Примеры

**Пример 1: Минимальный сквозной процесс**
```
P = ⟨f₁, f₂⟩
Выбираем: start(P) = f₁, end(P) = f₂
Условие: f₁ ≠ f₂ ⇒ ПРОЦЕСС СКВОЗНОЙ
```

**Пример 2: Несквозной процесс (концы совпадают)**
```
P = ⟨f₁, f₂, f₃⟩
Выбираем: start(P) = f₁, end(P) = f₁
Условие: f₁ = f₁ ⇒ ПРОЦЕСС НЕ СКВОЗНОЙ
```

**Пример 3: Произвольные концы внутри процесса**
```
P = ⟨f₁, f₂, f₃, f₄, f₅⟩
Выбираем: start(P) = f₂, end(P) = f₄
Условие: f₂ ≠ f₄ ⇒ ПРОЦЕСС СКВОЗНОЙ (частично)
```

### Особые случаи

1. **Процесс длины 1:**
   ```
   P = ⟨f₁⟩
   Любой выбор: start(P) = f₁, end(P) = f₁
   f₁ = f₁ ⇒ НЕ СКВОЗНОЙ
   ```

2. **Крайние точки по умолчанию:**
   Часто по умолчанию принимают:
   ```
   start(P) = p₁  // первый элемент
   end(P) = pₘ    // последний элемент
   ```
   Тогда процесс сквозной, если `p₁ ≠ pₘ`.

### Таблица истинности для различных выборов концов

| Процесс P | Выбранный start | Выбранный end | s ≠ e? | Сквозной? |
|-----------|----------------|---------------|--------|-----------|
| ⟨f₁, f₂⟩ | f₁ | f₂ | Да | Да |
| ⟨f₁, f₂⟩ | f₁ | f₁ | Нет | Нет |
| ⟨f₁, f₂, f₃⟩ | f₁ | f₃ | Да | Да |
| ⟨f₁, f₂, f₃⟩ | f₂ | f₂ | Нет | Нет |
| ⟨f₁⟩ | f₁ | f₁ | Нет | Нет |
| ⟨f₁, f₂, f₁⟩ | f₁ | f₁ | Нет | Нет |
| ⟨f₁, f₂, f₁⟩ | f₁ | f₂ | Да | Да |

### Связь с кросс-функциональностью

Можно определить **строго сквозной кросс-функциональный процесс**:

```
СтрогоСквознойКроссФункциональный(P) ⇔ 
    (Сквозной(P, 1, m)) ∧ (КроссФункциональный(P)) ∧ (type(p₁) ≠ type(pₘ))
```

Это означает:
1. Процесс сквозной от начала до конца
2. Процесс кросс-функциональный
3. Начальная и конечная функции разного типа

### Мера сквозности

Для количественной оценки можно ввести **меру сквозности**:

```
Сквозность(P, s, e) = distance(s, e) / max_distance(P)
```

где:
- `distance(s, e)` — минимальное количество шагов от s до e в графе процесса
- `max_distance(P)` — максимальное возможное расстояние в процессе P

Пример:
```
P = ⟨f₁, f₂, f₃, f₄⟩
Если s = f₁, e = f₄, то distance = 3, max_distance = 3 ⇒ Сквозность = 1.0
Если s = f₁, e = f₂, то distance = 1, max_distance = 3 ⇒ Сквозность = 0.33
```

### Практическая интерпретация в BPM

В терминах BPM:

1. **Произвольность выбора концов** отражает возможность выделения подпроцессов:
   - Можно анализировать процесс "от заявки до оплаты"
   - Или "от согласования до исполнения"
   - Или "от получения сырья до отгрузки"

2. **Типичные паттерны:**
   ```python
   def identify_e2e_patterns(process):
       patterns = []
       
       # Паттерн 1: Полный end-to-end
       if is_cross_functional(process) and process[0] != process[-1]:
           patterns.append("FULL_END_TO_END")
       
       # Паттерн 2: Частичный end-to-end
       for i in range(len(process)):
           for j in range(i+1, len(process)):
               if process[i] != process[j]:
                   patterns.append(f"PARTIAL_E2E_{i}_{j}")
       
       return patterns
   ```

3. **Оптимизация сквозных процессов:**
   - Выявление "разрывов" в сквозных процессах
   - Укорочение расстояния между критическими точками
   - Устранение циклов возврата к начальным точкам

### Алгоритм определения

```
function isEndToEnd(process, start_index=1, end_index=None):
    if end_index is None:
        end_index = length(process)
    
    if start_index == end_index:
        return FALSE  # Один и тот же элемент
    
    start_element = process[start_index-1]
    end_element = process[end_index-1]
    
    return start_element != end_element

function findAllE2ESegments(process):
    segments = []
    n = length(process)
    
    for i in range(0, n):
        for j in range(i+1, n):
            if process[i] != process[j]:
                segments.append({
                    'start': i,
                    'end': j,
                    'length': j-i,
                    'start_func': process[i],
                    'end_func': process[j]
                })
    
    return segments
```

### Связь с BPMN элементами

В BPMN:
- `start(P)` соответствует Start Event
- `end(P)` соответствует End Event
- Сквозной процесс соответствует последовательности от одного Start Event до одного End Event через различные Activities

### Выводы

1. **Сквозной процесс** — более слабое условие, чем **кросс-функциональный**
2. Любой процесс длины ≥2 с различными выбранными концами можно считать сквозным
3. Практическая ценность — в возможности выделять и анализировать подпроцессы между произвольными точками
4. Формализм позволяет измерять степень "сквозности" через расстояние между выбранными точками

Это определение дает гибкость для анализа бизнес-процессов на разных уровнях детализации и для разных целей оптимизации.

### 2

## Формальное определение сквозного процесса версии 2 (E2Ev2)

### Базовые структуры

**Множество функций:**
```
F = {f₁, f₂, ..., fₙ}
```

**Каталог продуктов компании:**
```
ProductCatalog = {prod₁, prod₂, ..., prodₖ}
```

**Функция выхода (результата) процесса:**
```
output: F → 2^{ProductCatalog}
```
где `output(f)` — множество продуктов, которые функция `f` реализует (может быть пустым).

**Процесс как последовательность:**
```
P = ⟨p₁, p₂, ..., pₘ⟩ где pᵢ ∈ F для всех i = 1..m
```

### Основное определение

**Процесс P является сквозным версии 2 (E2Ev2) тогда и только тогда, когда:**

```
∃i,j ∈ {1, 2, ..., m}: (i < j) ∧ (pᵢ ≠ pⱼ) ∧ (output(pⱼ) ∩ ProductCatalog ≠ ∅)
```

### Компоненты условия

1. **Разные позиции:** `i < j` — стартовая позиция раньше финишной
2. **Разные функции:** `pᵢ ≠ pⱼ` — стартовая и финишная функции различны (как элементы F)
3. **Продукт в каталоге:** `output(pⱼ) ∩ ProductCatalog ≠ ∅` — финишная функция реализует хотя бы один продукт из каталога

### Альтернативное определение (с явным указанием концов)

Для заданных индексов i и j:
```
E2Ev2(P, i, j) ⇔ (i < j) ∧ (pᵢ ≠ pⱼ) ∧ (output(pⱼ) ∩ ProductCatalog ≠ ∅)
```

### Примеры

**Пример 1: E2Ev2 процесс**
```
F = {f₁, f₂, f₃}
ProductCatalog = {ПродуктА}
output(f₁) = ∅, output(f₂) = {ПродуктА}, output(f₃) = ∅

P = ⟨f₁, f₂, f₃⟩
Проверяем пару (1,2):
- i=1 < j=2 ✓
- p₁ = f₁ ≠ p₂ = f₂ ✓
- output(f₂) ∩ ProductCatalog = {ПродуктА} ≠ ∅ ✓
⇒ E2Ev2(P) = TRUE
```

**Пример 2: Не E2Ev2 (нет продукта в каталоге)**
```
P = ⟨f₁, f₂, f₃⟩
output(f₁) = ∅, output(f₂) = {ВнутреннийОтчет}, output(f₃) = ∅
ProductCatalog = {ПродуктА}

Для всех пар:
- output(f₂) ∩ ProductCatalog = ∅
⇒ E2Ev2(P) = FALSE
```

**Пример 3: Не E2Ev2 (функции совпадают)**
```
P = ⟨f₁, f₁⟩
output(f₁) = {ПродуктА}
ProductCatalog = {ПродуктА}

Для пары (1,2):
- i=1 < j=2 ✓
- p₁ = f₁ = p₂ ✗ (условие pᵢ ≠ pⱼ не выполняется)
⇒ E2Ev2(P) = FALSE
```

**Пример 4: Не E2Ev2 (процесс длины 1)**
```
P = ⟨f₁⟩
output(f₁) = {ПродуктА}
ProductCatalog = {ПродуктА}

Нет пар i < j (требуется минимум 2 элемента)
⇒ E2Ev2(P) = FALSE
```

### Таблица истинности

| Процесс P | output(p₁) | output(p₂) | output(p₃) | Условия | E2Ev2? |
|-----------|------------|------------|------------|---------|--------|
| ⟨f₁, f₂⟩ | ∅ | {ПродуктА} | — | p₁≠p₂, output(p₂)∩Catalog≠∅ | Да |
| ⟨f₁, f₂⟩ | {ПродуктА} | ∅ | — | p₁≠p₂, но output(p₂)∩Catalog=∅ | Нет |
| ⟨f₁, f₁⟩ | {ПродуктА} | {ПродуктА} | — | p₁=p₁ (не различны) | Нет |
| ⟨f₁, f₂, f₃⟩ | ∅ | ∅ | {ПродуктА} | Существует пара (1,3) или (2,3) | Да |
| ⟨f₁⟩ | {ПродуктА} | — | — | Нет пары i<j | Нет |

### Алгоритм проверки

```python
def is_E2Ev2(process, output_func, product_catalog):
    """Проверяет, является ли процесс E2Ev2"""
    m = len(process)
    
    # Процесс должен содержать минимум 2 функции
    if m < 2:
        return False
    
    # Проверяем все возможные пары (i, j) где i < j
    for i in range(m):
        for j in range(i + 1, m):
            if (process[i] != process[j] and  # разные функции
                output_func(process[j]) and    # выход не пустой
                any(prod in product_catalog for prod in output_func(process[j]))):
                return True
    
    return False
```

### Связь с бизнес-процессами

**Практическая интерпретация:**
- `ProductCatalog` — перечень товаров/услуг, которые компания продает клиентам
- `output(pⱼ)` — результат выполнения функции (может быть промежуточным или конечным)
- E2Ev2 процесс гарантирует, что существует путь от некоторой начальной функции к функции, создающей продукт для клиента

**Важные замечания:**
1. Начальная функция может быть произвольной (не обязательно первой в процессе)
2. Требуется только существование хотя бы одной подходящей пары функций
3. Процесс может содержать несколько E2Ev2 подпроцессов
4. Функция может создавать несколько продуктов одновременно

### Расширенная версия с весами

Для процессов с вероятностным выполнением можно ввести вероятности:

```
P = ⟨(p₁, w₁), (p₂, w₂), ..., (pₘ, wₘ)⟩
где wᵢ ∈ [0,1] — вероятность выполнения функции pᵢ
```

Тогда условие модифицируется:
```
E2Ev2(P) ⇔ ∃i,j: (i < j) ∧ (pᵢ ≠ pⱼ) ∧ (output(pⱼ) ∩ ProductCatalog ≠ ∅) ∧ (wᵢ > 0) ∧ (wⱼ > 0)
```

### Связь с BPMN

В терминах BPMN:
- `pⱼ` соответствует Activity, связанной с End Event типа "Message" или "Signal"
- `ProductCatalog` соответствует Message Definitions
- E2Ev2 процесс соответствует последовательности от некоторого Start Event до End Event, который генерирует сообщение о создании продукта

### Критерии оптимизации

Процессы можно ранжировать по степени "сквозности версии 2":

1. **Количество E2Ev2 пар:** Чем больше пар (i,j) удовлетворяют условию, тем процесс более сквозной
2. **Длина E2Ev2 отрезка:** `j - i` — чем короче путь до создания продукта, тем лучше
3. **Ценность продукта:** Можно учесть ценность продуктов в каталоге:
   ```
   Value(E2Ev2 отрезка) = max{value(prod) | prod ∈ output(pⱼ) ∩ ProductCatalog}
   ```

### Выводы

1. E2Ev2 — более строгое условие, чем базовый сквозной процесс
2. Требует интеграции с продуктовой стратегией компании (каталог продуктов)
3. Позволяет выделить процессы, непосредственно создающие ценность для клиента
4. Дает основу для оптимизации процессов на создание продуктов

Этот формализм позволяет систематически анализировать, какие процессы в организации действительно заканчиваются созданием продуктов для клиентов, а какие являются вспомогательными или незавершенными.
